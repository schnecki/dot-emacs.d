-- ControlledVisit.hs --- 
-- 
-- Filename: ControlledVisit.hs
-- Description: 
-- Author: Manuel Schneckenreither
-- Maintainer: 
-- Created: Sa Okt 12 15:41:14 2013 (+0200)
-- Version: 
-- Package-Requires: ()
-- Last-Updated: Mo Okt 14 17:25:28 2013 (+0200)
--           By: Manuel Schneckenreither
--     Update #: 63
-- URL: 
-- Doc URL: 
-- Keywords: 
-- Compatibility: 
-- 
-- 

-- Commentary: 
-- 
-- 
-- 
-- 

-- Change Log:
-- 
-- 
-- Code:

import Control.Monad (forM, liftM, filterM)
import System.Time (ClockTime(..))
import System.FilePath ((</>), takeExtension)
import System.Directory (Permissions(..), getModificationTime, getPermissions, getDirectoryContents)
import Control.OldException (bracket, handle)
import System.IO (IOMode(..), hClose, hFileSize, openFile)
import GHC.Exts (sortWith)
import BetterPredicate
import Data.List (sortBy, isInfixOf)
import Data.Ord (comparing)


data Info = Info { infoPath :: FilePath
                 , infoPerms :: Maybe Permissions
                 , infoSize :: Maybe Integer
                 , infoModTime :: Maybe ClockTime
                 } deriving (Eq, Ord, Show)

traverseP :: (Info -> Bool) -> ([Info] -> [Info]) -> FilePath -> IO [Info]
traverseP pred order  = traverse ord
  where ord list = filter pred (order list) 


myFilter :: Info -> Bool
myFilter info = isInfixOf "Visit" (infoPath info)


traverse :: ([Info] -> [Info]) -> FilePath -> IO [Info]
traverse order path = do
  names <- getUsefulContents path
  contents <- mapM getInfo (path : map (path </>) names)
  liftM concat $ forM (order contents) $ \info -> do
    if isDirectory info && infoPath info /= path
      then traverse order (infoPath info)
      else return [info]

getUsefulContents :: FilePath -> IO [String]           
getUsefulContents path = do
  names <- getDirectoryContents path
  return (filter (`notElem` [".", ".."]) names)

isDirectory :: Info -> Bool
isDirectory = maybe False searchable . infoPerms


maybeIO :: IO a -> IO (Maybe a)
maybeIO act = handle (\_ -> return Nothing) (Just `liftM` act)

getInfo :: FilePath -> IO Info
getInfo path = do
  perms <- maybeIO (getPermissions path)
  size <- maybeIO (bracket (openFile path ReadMode) hClose hFileSize)
  modified <- maybeIO (getModificationTime path)
  return (Info path perms size modified)



  
-- 
-- ControlledVisit.hs ends here
