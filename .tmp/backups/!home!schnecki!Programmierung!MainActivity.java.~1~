package at.ac.uibk.sch_sch_str.colorbasedtracker;

import ioio.lib.api.exception.ConnectionLostException;
import ioio.lib.util.IOIOLooper;
import ioio.lib.util.android.IOIOActivity;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import org.opencv.android.BaseLoaderCallback;
import org.opencv.android.CameraBridgeViewBase;
import org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;
import org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;
import org.opencv.android.LoaderCallbackInterface;
import org.opencv.android.OpenCVLoader;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfDouble;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.Window;
import android.view.WindowManager;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends IOIOActivity implements CvCameraViewListener2 {

	private static final String TAG = MainActivity.class.getSimpleName();

	private static Rect PREVIEW_SIZE = new Rect(20, 40, 60, 60);

	public static final String TRACKING_MODE = "TRACKING_MODE";

	private Mat mRgba;
	private Mat mTouchedColorRgba;
	private Scalar touchedColor;

	private Point mCenterOfView;

	public static boolean isColorChosen = false;

	private boolean inColorChoseMode = false;

	private Mat mColorPreview;

//	private static Mat H;
	private HMatrix hMatrix = HMatrix.getInstance();
private Metrics metrics = new Metrics();	
	
	
	private Calendar lastRobotAction = Calendar.getInstance();

	private CameraBridgeViewBase mOpenCvCameraView;

	private BlackWhiteVisualizer mVisualizer;
	private ChessboardCalibrator mCalibrator;

	private ColorManager cManager = ColorManager.getInstance();

	private RobotControl robotControl = RobotControl.getInstance();

	private TextView debugView;

	private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {
		@Override
		public void onManagerConnected(int status) {
			switch (status) {
			case LoaderCallbackInterface.SUCCESS: {
				Log.i(TAG, "OpenCV loaded successfully");
				mOpenCvCameraView.enableView();
			}
				break;
			default: {
				super.onManagerConnected(status);
			}
				break;
			}
		}
	};
	private boolean found = false;
//	private int frameCount = 0;

	@Override
	protected IOIOLooper createIOIOLooper() {
		return RobotControl.getInstance();
	}

	public MainActivity() {
		Log.i(TAG, "Instantiated new " + this.getClass());
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		Log.i(TAG, "called onCreate");
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

		setContentView(R.layout.activity_main);

		debugView = (TextView) findViewById(R.id.debugView);

		mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.activity_main_view);
		mOpenCvCameraView.setCvCameraViewListener(this);

	}

	@Override
	public void onPause() {
		super.onPause();
		if (mOpenCvCameraView != null)
			mOpenCvCameraView.disableView();
		robotControl = null;
	}

	@Override
	public void onResume() {
		super.onResume();
		OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_2_4_3, this,
				mLoaderCallback);
		robotControl = RobotControl.getInstance();
		if (isColorChosen)
			mVisualizer.addColorToProcess(cManager.getTrackingColor());

	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		if (mOpenCvCameraView != null)
			mOpenCvCameraView.disableView();
	}

	/*
	 * @Override public boolean onTouch(View v, MotionEvent event) {
	 * 
	 * if (inColorChoseMode) {
	 * 
	 * // mostly taken (simplified a bit) from OpenCV Sample - //
	 * color-blob-detection ColorBlobDetectionActivity.java
	 * 
	 * int cols = mRgba.cols(); int rows = mRgba.rows();
	 * 
	 * int xOffset = (mOpenCvCameraView.getWidth() - cols) / 2; int yOffset =
	 * (mOpenCvCameraView.getHeight() - rows) / 2;
	 * 
	 * int x = (int) event.getX() - xOffset; int y = (int) event.getY() -
	 * yOffset;
	 * 
	 * Log.i(TAG, "cols: " + cols + " rows: " + rows); Log.i(TAG, "Width: " +
	 * mOpenCvCameraView.getWidth() + " Heigth: " +
	 * mOpenCvCameraView.getHeight());
	 * 
	 * Log.d(TAG, "Touch image coordinates: (" + x + ", " + y + ")");
	 * 
	 * if ((x < 0) || (y < 0) || (x > cols) || (y > rows)) return false;
	 * 
	 * mTouchedColorRgba = mRgba.submat(new Rect(x, y, 1, 1));
	 * 
	 * touchedColor = Core.sumElems(mTouchedColorRgba);
	 * 
	 * Log.d(TAG, "Touched color (RGBA): (" + touchedColor.val[0] + ", " +
	 * touchedColor.val[1] + ", " + touchedColor.val[2] + ", " +
	 * touchedColor.val[3] + ")");
	 * 
	 * // set color for the visualization (has to be HSV)
	 * mVisualizer.setHsvColor(ColorManager.converScalarRgba2Hsv( new
	 * Color(touchedColor, "touched Color", Color.RGB)) .getVec());
	 * 
	 * mVisualizer.process(mRgba);
	 * 
	 * mVisualizer.getMc();
	 * 
	 * return true;
	 * 
	 * }
	 * 
	 * // if color is already chosen, ignore any touch event if (isColorChosen)
	 * { return true; }
	 * 
	 * // mostly taken (simplified a bit) from OpenCV Sample - //
	 * color-blob-detection ColorBlobDetectionActivity.java
	 * 
	 * int cols = mRgba.cols(); int rows = mRgba.rows();
	 * 
	 * int xOffset = (mOpenCvCameraView.getWidth() - cols) / 2; int yOffset =
	 * (mOpenCvCameraView.getHeight() - rows) / 2;
	 * 
	 * int x = (int) event.getX() - xOffset; int y = (int) event.getY() -
	 * yOffset;
	 * 
	 * Log.i(TAG, "cols: " + cols + " rows: " + rows); Log.i(TAG, "Width: " +
	 * mOpenCvCameraView.getWidth() + " Heigth: " +
	 * mOpenCvCameraView.getHeight());
	 * 
	 * Log.d(TAG, "Touch image coordinates: (" + x + ", " + y + ")");
	 * 
	 * if ((x < 0) || (y < 0) || (x > cols) || (y > rows)) return false;
	 * 
	 * mTouchedColorRgba = mRgba.submat(new Rect(x, y, 1, 1));
	 * 
	 * touchedColor = Core.sumElems(mTouchedColorRgba);
	 * 
	 * Log.d(TAG, "Touched color (RGBA): (" + touchedColor.val[0] + ", " +
	 * touchedColor.val[1] + ", " + touchedColor.val[2] + ", " +
	 * touchedColor.val[3] + ")");
	 * 
	 * isColorChosen = true;
	 * 
	 * // set color for the visualization (has to be HSV)
	 * mVisualizer.setHsvColor(ColorManager.converScalarRgba2Hsv( new
	 * Color(touchedColor, "touched Color", Color.RGB)).getVec());
	 * 
	 * return true; }
	 */

	@Override
	public void onCameraViewStarted(int width, int height) {

		// initialize some objects
		mRgba = new Mat(height, width, CvType.CV_8UC4);
		mTouchedColorRgba = new Mat();

		mVisualizer = BlackWhiteVisualizer.getInstance();
		mCalibrator = new ChessboardCalibrator(8, 5);
		touchedColor = new Scalar(0);

		mCenterOfView = new Point(mOpenCvCameraView.getWidth() / 2,
				mOpenCvCameraView.getHeight() / 2);

		Log.i(TAG, "CenterOfView: " + mCenterOfView);

		// Show instruction message
		Toast toast = Toast.makeText(this, R.string.start_msg,
				Toast.LENGTH_LONG);
		toast.show();
	}

	@Override
	public void onCameraViewStopped() {
		mRgba.release();
	}

	@Override
	public Mat onCameraFrame(CvCameraViewFrame inputFrame) {

		mRgba = inputFrame.rgba();

		Log.i(TAG, "Chosen: " + isColorChosen);

		// only process if a color has been chosen already
		if (isColorChosen) {

			mVisualizer.process(mRgba);

			// Log.d(TAG, "Contours count: " + contours.size());

			Color c = cManager.getTrackingColor();

			Blob b = mVisualizer.getBlobs().get(c);

			if (b == null) {
				return mRgba;
			}

			Blob.drawBlobWithExtras(mRgba, b);

			mColorPreview = mRgba.submat(PREVIEW_SIZE); // extract a submatrix
														// from the camera image

			// TODO: fix convertion method
			mColorPreview.setTo(ColorManager.convertScalarHsv2Rgba(
					cManager.getTrackingColor()).getVec());

		} else {

			if (robotControl.isServoDown()) {

				try {
					robotControl.adjustBar(false);
				} catch (ConnectionLostException e) {
					debug(e.getMessage());
				} catch (RobotNotConnectedException e) {
					debug(e.getMessage());
				}
			}
		}

		if (found) {

			// ------ DRAW CHESSBOARD CORNERS //
			// Calib3d.drawChessboardCorners(mRgba, mCalibrator.getBoardSize(),
			// mCalibrator.getmCorner(), found);

			// TODO: Set flag if in ColorDetect Mode
			if (isColorChosen) {

				Point imgPoint = mVisualizer.getBlobs()
						.get(cManager.getTrackingColor()).getBottomOfContour();

				// Image coordinates in homogeneous coordinates
				Mat imgCoordinate = new MatOfDouble(imgPoint.x, imgPoint.y, 1);

//				Mat realCoordinate = new MatOfDouble();
//
				
//

				// realCoordinates = H * imgCoordinates
//				Core.gemm(H, imgCoordinate, 1, new Mat(), 0, realCoordinate);

				Mat realCoordinate = hMatrix.getRealCoordinates(imgCoordinate);
				printMat("realCoords Homogeneous", realCoordinate);
				
				
				Point realCoordinateEuclid = metrics.getEuclidCoordinate(realCoordinate);
				
				double dist = metrics.getDistance(realCoordinateEuclid);
				
//				double x = realCoordinate.get(0, 0)[0];
//				double y = realCoordinate.get(1, 0)[0];
//				double z = realCoordinate.get(2, 0)[0];
//
//				// homogeneous in euclidean
//				realCoordinateEuclid = new Point(x / z, y / z);
//
//				Log.i("realCoordinates Euclid", realCoordinateEuclid.x + " , "
//						+ realCoordinateEuclid.y);
//
//				// calc Distance using Pythagoras a� + b� = c�
//				double dist = Math.sqrt(Math.pow(realCoordinateEuclid.x, 2)
//						+ Math.pow(realCoordinateEuclid.y, 2));
//
//				dist /= 10;

				double angle = computeAngle(realCoordinateEuclid);

				int angleInt = (int) angle;
				byte angleByte = (byte) angleInt;

				Core.putText(mRgba, "Turn Angle by " + angleByte + " degrees",
						new Point(20, 300), Core.FONT_HERSHEY_SIMPLEX, 1,
						ColorManager.RED);

				Calendar now = Calendar.getInstance();
				now.add(Calendar.SECOND, -1);

				if (lastRobotAction.before(now)) {

					if (!adjustAngle((int) angle)) {

						if (!adjustDistance((int) dist)) {

							if (dist < 12) {
								robotControl.setThreshold(15);
							} else {
								robotControl.setThreshold(4);
							}

							if (!RobotControl.getInstance().isServoDown()) {
								adjustServo(false);

								// siegespose :)
								adjustAngle(360);
								adjustServo(true);
								adjustServo(false);

							}
						}
					}

					// Green Circle in the Center of the View
					Core.circle(mRgba, mCenterOfView, 8, ColorManager.GREEN, -1);

				}
				// Bottom Pixel of the Color Blob
				Core.circle(mRgba, imgPoint, 5, ColorManager.GREEN, -1);

				Core.putText(mRgba, "Distance   Angle:", new Point(20, 125),
						Core.FONT_HERSHEY_SIMPLEX, 1, ColorManager.RED);
				Core.putText(mRgba, (int) dist + "   " + angle, new Point(20,
						155), Core.FONT_HERSHEY_SIMPLEX, 1, ColorManager.RED);

			}

		}

		return mRgba;
	}

	private boolean adjustAngle(int angle) {

		boolean turned = false;

		try {
			turned = robotControl.turn((byte) angle);
			lastRobotAction = Calendar.getInstance();
			return turned;
		} catch (ConnectionLostException e) {
			debug(e.getMessage());
		} catch (InterruptedException e) {
			debug(e.getMessage());
		} catch (RobotNotConnectedException e) {
			debug(e.getMessage());
		}

		return true;

	}

	private boolean adjustDistance(int dist) {

		if (dist > 110) {
			dist = 100;
		}

		if (dist <= 15)
			return false;

		try {
			robotControl.move((byte) dist);
			lastRobotAction = Calendar.getInstance();
		} catch (Exception e) {
			debug(e.getMessage());
		}

		return true;
	}

	private boolean adjustServo(boolean up) {
		try {

			RobotControl.getInstance().grab(up);
		} catch (Exception ex) {
		}

		if (up) {
			RobotControl.getInstance().setServoDown(!up);
		} else {
			RobotControl.getInstance().setServoDown(up);
		}

		return true;
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {

		MenuInflater inflater = getMenuInflater();
		inflater.inflate(R.menu.optionsmenu, menu);

		return super.onCreateOptionsMenu(menu);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {

		Toast toast = Toast.makeText(this, null, Toast.LENGTH_LONG);

		switch (item.getItemId()) {

		case R.id.chess:

			Mat calibImg = mRgba;

			hMatrix.calculateHMatix(mCalibrator, calibImg);
			
//			H = mCalibrator.calibrate(calibImg);

			found = mCalibrator.isFound();

			if (found) {
				toast.setText("Calibration successfull.");

				// drive from calibration sheet
				try {
					robotControl.move(-25);
				} catch (ConnectionLostException e) {
					debug(e.getMessage());
				} catch (InterruptedException e) {
					debug(e.getMessage());
				} catch (RobotNotConnectedException e) {
					debug(e.getMessage());
				}

			} else {
				toast.setText("Calibration failed. Try again.");
			}

			toast.show();

			return true;

		case R.id.liftBar:

			if (!RobotControl.getInstance().isServoDown()) {
				adjustServo(true);

			}
			Toast.makeText(this, "Bar Lifted", Toast.LENGTH_LONG).show();

			return true;

		case R.id.dropBar:

			if (!RobotControl.getInstance().isServoDown()) {
				adjustServo(false);

			}
			Toast.makeText(this, "Bar dropped", Toast.LENGTH_LONG).show();

			return true;

		case R.id.selectColor: {
			Intent intent = new Intent(this, ColorSelectionActivity.class);

			intent.putExtra(TRACKING_MODE, R.id.selectColor);

			startActivity(intent);

			return true;
		}
		case R.id.selectTrackingColor: {

			Intent intent = new Intent(this, ColorSelectionActivity.class);

			intent.putExtra(TRACKING_MODE, R.id.selectTrackingColor);

			startActivity(intent);

			return true;
		}

		case R.id.startOrientation:

			if (cManager.getColors().size() < 2) {
				Toast.makeText(
						this,
						"No additional Colors selected, first select a 0-Bottle color and their neigbor bottle color!",
						Toast.LENGTH_LONG).show();
				return true;
//			} else if (!found) {
//				Toast.makeText(this, "System not calibrated yet!",
//						Toast.LENGTH_LONG).show();
//				return true;

			}

			Intent intent = new Intent(this, OrientationActivity.class);
			startActivity(intent);

			return true;

		case R.id.resetAllColors:

			cManager.resetAllColors();
			Toast.makeText(this, "All Colors resettet", Toast.LENGTH_SHORT)
					.show();

			return true;

		case R.id.resetOnlyNonTracking:
			cManager.resetOnlyNonTracking();
			Toast.makeText(this,
					"All Colors except the Tracking Color resettet",
					Toast.LENGTH_SHORT).show();

			return true;

		case R.id.resetTrackingColor:
			cManager.resetTrackingColor();
			Toast.makeText(this, "Tracking Color resettet", Toast.LENGTH_SHORT)
					.show();

			return true;

		default:

			return super.onOptionsItemSelected(item);
		}
	}

	/**
	 * 
	 * Computes the angle (in degree) between the specified point p and the
	 * center of the image.
	 * 
	 * @param p
	 *            Point to compute angel
	 * 
	 * @return angle in degrees
	 */
	private double computeAngle(Point p) {

		double angle;
		Point point = p.clone();

		/*
		 * 
		 * // if point is in the right side of the image if (point.x >
		 * mCenterOfView.x) { point.x = mCenterOfView.x - point.x; angle =
		 * Math.toDegrees(Math.acos(point.x / mCenterOfView.x)); angle = angle -
		 * 90;
		 * 
		 * } else { // if point is in the left side of the image angle =
		 * Math.toDegrees(Math.acos(point.x / mCenterOfView.x)); angle = angle *
		 * -1;
		 * 
		 * 
		 * }
		 */

		angle = Math.toDegrees(Math.atan(point.x / point.y));

		angle = Math.round(angle);

		angle *= -1;

		Log.i(TAG, "Angle: " + angle);

		return angle;

	}

	@Override
	public void onBackPressed() {

		// change the behavior of the back button

		if (isColorChosen) {
			Log.d(TAG, "Back Pressed, choose Color again");
			isColorChosen = false;
		} else {
			Log.d(TAG, "Back Pressed, close app");
			super.onBackPressed();
		}

	}

	/**
	 * Print a formatted String of the matrix m.
	 * 
	 * @param name
	 *            name of the matrix
	 * @param m
	 *            the matrix
	 */
	public static void printMat(String name, Mat m) {

		StringBuilder builder = new StringBuilder();

		int arrSize;
		double[] value;

		Log.i(name, "Matrix: " + name);

		for (int i = 0; i < m.rows(); i++) {
			builder.append("[ ");

			for (int j = 0; j < m.cols(); j++) {

				value = m.get(i, j);

				arrSize = value.length;

				// print brackets only with coordinates
				if (arrSize > 1)
					builder.append("(");

				for (int k = 0; k < arrSize; k++) {
					builder.append(value[k]);

					if (k != arrSize - 1)
						builder.append(", ");

				}

				if (arrSize > 1)
					builder.append(") ");

				builder.append("  ");
			}

			builder.append("]");
			Log.i(name, builder.toString());
			builder = new StringBuilder();

		}

		// Log.d(TAG, builder.toString());

	}

	/**
	 * Log the Message to the DebugView TextView in the Activity.
	 * 
	 * If 20 lines are displayed, reset and start at the first line.
	 * 
	 * @param msg
	 *            Error Message to display
	 */
	private void debug(String msg) {

		String oldMsg = (String) debugView.getText();

		int line = oldMsg.split("\n", 20).length;

		final String newMsg = line == 20 ? "...\n" + msg : oldMsg + "\n" + msg;

		// necessary if the method is called outside MainActivity (shouldn't be
		// possible, i know, but it is somehow. :D )
		runOnUiThread(new Runnable() {

			@Override
			public void run() {

				debugView.setText(newMsg);

			}
		});

	}
}